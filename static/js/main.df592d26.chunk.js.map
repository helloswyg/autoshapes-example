{"version":3,"sources":["lib/shapelib/utils.ts","lib/shapelib/library.ts","lib/shapelib/index.ts","components/Header/Header.tsx","components/Footer/Footer.tsx","components/Hero/Hero.tsx","components/Section/Section.tsx","components/App/App.tsx","reportWebVitals.ts","index.tsx"],"names":["flip","pathArray","how","flattenedArray","flat","numberCounter","index","length","element","PathArray","flipY","scale","factor","value","small","big","pathCompose","segments","output","forEach","segment","flattenedOutput","flattenedSegment","x","y","concat","loopSegment","reverseLoopSegment","curveSegment90","reverseCurveSegment90","curveSegment45","reverseCurveSegment45","connectorSegment","reverseConnectorSegment","horizontalrSegment","loop","crest","connector","twistConnector","flipX","nPointRadial","radialDistances","offset","numSegments","i","d","Math","sin","PI","cos","controlPointX","controlPointY","drawTestCurve","elementID","draw","SVG","addTo","size","gradient","add","stop","composedPath","library","transformParams","rotate","translateX","translateY","path","fill","stroke","color","url","width","opacity","transform","polyline","PointArray","toPointArray","Header","className","Footer","Hero","Section","props","children","App","useEffect","shapelib","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"mNAmBO,SAASA,EAAKC,EAAsBC,GAIzC,IAHA,IAAIC,EAAiBF,EAAUG,OAC3BC,EAAgB,EAEXC,EAAQ,EAAGA,EAAQH,EAAeI,OAAQD,IAAS,CAC1D,IAAME,EAAUL,EAAeG,GACR,kBAAZE,IACG,MAARN,IAEFC,EAAeG,GAASD,EAAgB,IAAM,EAAIG,GAAWA,GAEnD,MAARN,IAEFC,EAAeG,GAASD,EAAgB,IAAM,EAAIG,GAAWA,GAE/DH,GAAiB,GAGrB,OAAO,IAAII,IAAUN,GAGhB,SAASO,EAAMT,GACpB,OAAOD,EAAKC,EAAW,KAWlB,SAASU,EAAMV,EAAsBW,GAG1C,IADA,IAAIT,EAAiBF,EAAUG,OACtBE,EAAQ,EAAGA,EAAQH,EAAeI,OAAQD,IAAS,CAC1D,IAAMO,EAAQV,EAAeG,GACR,kBAAVO,IACTV,EAAeG,GAASO,EAAQD,GAGpC,OAAO,IAAIH,IAAUN,GAGhB,SAASW,EAAMb,GACpB,OAAOU,EAAMV,EAAW,IAGnB,SAASc,EAAId,GAClB,OAAOU,EAAMV,EAAW,GAgBnB,SAASe,EAAYC,GAK1B,IAAIC,EAAS,IAAIT,IAwBjB,MAvB8B,MAA1BQ,EAAS,GAAGb,OAAO,KACrBc,EAASA,EAAS,IAAIT,IAAU,UAGlCQ,EAASE,SAAQ,SAACC,GAChB,IAAMC,EAAkBH,EAAOd,OAC3BkB,EAAmBF,EAAQhB,OACzBmB,EAAIF,EAAgBA,EAAgBd,OAAS,GAC7CiB,EAAIH,EAAgBA,EAAgBd,OAAS,GAC/CF,EAAgB,EAEpB,GAAiB,kBAANkB,GAA+B,kBAANC,EAAgB,OAAON,EAC3D,IAAK,IAAIZ,EAAQ,EAAGA,EAAQgB,EAAiBf,OAAQD,IAAS,CAC5D,IAAME,EAAUc,EAAiBhB,GACV,kBAAZE,IAETc,EAAiBhB,GAASE,GAAWH,EAAgB,IAAM,EAAIkB,EAAIC,GACnEnB,GAAiB,GAGrBa,EAASA,EAAOO,OAAO,IAAIhB,IAAUa,OAGhCJ,EC1GT,IDwCuBjB,ECxCjByB,EAAc,IAAIjB,IAAU,wBAC5BkB,EAAqB,IAAIlB,IAAU,sBACnCmB,EAAiB,IAAInB,IAAU,yBAC/BoB,EAAwB,IAAIpB,IAAU,yBACtCqB,EAAiB,IAAIrB,IAAU,yBAC/BsB,EAAwB,IAAItB,IAAU,yBACtCuB,EAAmB,IAAIvB,IAAU,wBACjCwB,EAA0B,IAAIxB,IAAU,sBACxCyB,EAAqB,IAAIzB,IAAU,oBAiB5B0B,EAAOnB,EAAY,CAC9Bc,EACAJ,GDaqBzB,ECZd0B,EDaA3B,EAAKA,EAAKC,EAAW,KAAM,MCZlCS,EAAMqB,KAEKK,EAAQpB,EAAY,CAACc,EAAgBpB,EAAMqB,KAC3CM,EAAYrB,EAAY,CAACgB,EAAkBtB,EAAMuB,KACjDK,EAAiBtB,EAAY,CAACgB,EAAkBC,IACzCjB,EAAY,CAC9BY,EDCK,SAAe3B,GACpB,OAAOD,EAAKC,EAAW,KCDvBsC,CAAMb,GACNZ,EAAMA,EAAMoB,IACZxB,EAAMiB,GACNjB,EAAMmB,KAeR,SAASW,EAAaC,GAMpB,IALA,IACMC,EAAc,IAAdA,EAAsB,IACxBxB,EAAS,IAAIT,IAAU,CAAC,IAAKiC,EAAUA,EAAWD,EAAgB,KAChEE,EAAcF,EAAgBlC,OAE3BqC,EAAI,EAAGA,EAAIH,EAAgBlC,OAAS,EAAGqC,IAAK,CACnD,IAAMC,EAAIJ,EAAgBG,EAAID,GACxBpB,EAAIsB,EAAIC,KAAKC,IAAS,EAAJH,EAAQE,KAAKE,GAAML,GAAeD,EACpDlB,EAAIqB,EAAIC,KAAKG,IAAS,EAAJL,EAAQE,KAAKE,GAAML,GAAeD,EAGpDQ,EAAgB3B,GAFRuB,KAAKG,IAAS,EAAJL,EAAQE,KAAKE,GAAML,GAAeE,EAAKF,EAT9C,EAYXQ,EAAgB3B,EAFTsB,KAAKC,IAAS,EAAJH,EAAQE,KAAKE,GAAML,GAAeE,EAAKF,EAV7C,EAefzB,EADQ,IAAN0B,EACO1B,EAAOO,OAAO,CACrB,IACA,GAAKiB,EACLD,EAAgB,GAAKC,EACrBQ,EACAC,EACA5B,EACAC,IAGON,EAAOO,OAAO,CAAC,IAAKyB,EAAeC,EAAe5B,EAAGC,IAMlE,OAFAN,EAASA,EAAOO,OAAO,CAAC,MAKLe,EAAa,CAAC,GAAI,KAClBA,EAAa,CAAC,GAAI,GAAI,KACtBA,EAAa,CAAC,GAAI,GAAI,GAAI,KAC1BA,EAAa,CAAC,GAAI,GAAI,GAAI,IAAK,KCxF7C,SAASY,EAAcC,GAC5B,IAAMC,EAAYC,cAAMC,MAAMH,GAAWI,KAAK,OAAQ,QAChDC,EAAWJ,EAAKI,SAAS,UAAU,SAAUC,GACjDA,EAAIC,KAAK,EAAG,QACZD,EAAIC,KAAK,EAAG,WAERC,EAAe7C,EAAY,CAC/BF,EAAMJ,EAAMoD,IACZA,EAGAhD,EAAMgD,GAEN/C,EAAIL,EAAMoD,IACVA,IAGIC,EAAkB,CACtBC,OAAQ,GACRC,WAAY,EACZC,WAAY,IACZvD,MAAO,GACPX,KAAM,KAUR,OAPAsD,EACGa,KAAKN,GACLO,KAAK,QACLC,OAAO,CAAEC,MAAOZ,EAASa,MAAOC,MAAO,EAAGC,QAAS,KACnDC,UAAUX,GAEbT,EAAKqB,SF6BA,SAAsB1E,GAI3B,IAHA,IAAIE,EAAiBF,EAAUG,OAC3Bc,EAAmB,GAEdZ,EAAQ,EAAGA,EAAQH,EAAeI,OAAQD,IAAS,CAC1D,IAAME,EAAUL,EAAeG,GACR,kBAAZE,IACTU,EAASA,EAAOO,OAAOjB,IAG3B,OAAO,IAAIoE,IAAW1D,GEvCR2D,CAAahB,IAAeO,KAAK,QAAQC,OAAO,CAAEC,MAAO,OAAQE,MAAO,IAAKE,UAAUX,GAC9FT,E,WC5CF,SAASwB,IACd,OAAO,qBAAKC,UAAU,WCDjB,SAASC,IACd,OAAO,qBAAKD,UAAU,WCDjB,SAASE,IACd,OAAO,qBAAKF,UAAU,SCKjB,SAASG,EAAQC,GACtB,OAAO,qBAAKJ,UAAU,UAAf,SAA0BI,EAAMC,WCmB1BC,MAlBf,WAKE,OAJAC,qBAAU,WACRC,EAAuB,oBAIvB,sBAAKR,UAAU,MAAf,UACE,cAACD,EAAD,IACA,cAACI,EAAD,UACE,cAACD,EAAD,MAEF,cAACD,EAAD,QCLSQ,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,K","file":"static/js/main.df592d26.chunk.js","sourcesContent":["import { PathArray, PointArray } from '@svgdotjs/svg.js';\n\nexport function smooth(pathArray: PathArray): PathArray {\n  let flattenedArray = pathArray.flat();\n  if (flattenedArray[0] === 'S') {\n    return pathArray;\n  }\n  if (flattenedArray[0] === 'M') {\n    flattenedArray = flattenedArray.slice(3);\n  }\n  if (flattenedArray[0] === 'C') {\n    flattenedArray = flattenedArray.slice(2);\n    flattenedArray[0] = 'S';\n  } else {\n    throw new Error('Only cubic bezier curves are supported');\n  }\n  return new PathArray(flattenedArray);\n}\n\nexport function flip(pathArray: PathArray, how: 'x' | 'y'): PathArray {\n  let flattenedArray = pathArray.flat();\n  let numberCounter = 0;\n\n  for (let index = 0; index < flattenedArray.length; index++) {\n    const element = flattenedArray[index];\n    if (typeof element === 'number') {\n      if (how === 'y') {\n        // if element is at an even-numbered position it's an x coordidante otherwise a y coordinate\n        flattenedArray[index] = numberCounter % 2 === 0 ? element : -element;\n      }\n      if (how === 'x') {\n        // if element is at an even-numbered position it's an x coordidante otherwise a y coordinate\n        flattenedArray[index] = numberCounter % 2 === 1 ? element : -element;\n      }\n      numberCounter += 1;\n    }\n  }\n  return new PathArray(flattenedArray);\n}\n\nexport function flipY(pathArray: PathArray): PathArray {\n  return flip(pathArray, 'y');\n}\n\nexport function flipX(pathArray: PathArray): PathArray {\n  return flip(pathArray, 'x');\n}\n\nexport function flipXY(pathArray: PathArray): PathArray {\n  return flip(flip(pathArray, 'x'), 'y');\n}\n\nexport function scale(pathArray: PathArray, factor: number): PathArray {\n  // scale path relative to 0,0 means we simply multiply all numbers by factor\n  let flattenedArray = pathArray.flat();\n  for (let index = 0; index < flattenedArray.length; index++) {\n    const value = flattenedArray[index];\n    if (typeof value === 'number') {\n      flattenedArray[index] = value * factor;\n    }\n  }\n  return new PathArray(flattenedArray);\n}\n\nexport function small(pathArray: PathArray): PathArray {\n  return scale(pathArray, 0.5);\n}\n\nexport function big(pathArray: PathArray): PathArray {\n  return scale(pathArray, 2.0);\n}\n\nexport function toPointArray(pathArray: PathArray): PointArray {\n  let flattenedArray = pathArray.flat();\n  let output: number[] = [];\n\n  for (let index = 0; index < flattenedArray.length; index++) {\n    const element = flattenedArray[index];\n    if (typeof element === 'number') {\n      output = output.concat(element);\n    }\n  }\n  return new PointArray(output);\n}\n\nexport function pathCompose(segments: PathArray[]): PathArray {\n  // we assume that the last two numbers in a path segment are the end point of the path so far.\n  // That end point will be the starting point of the next segment.\n  // each segment is encoded as if starting at 0,0 so the segment has to be translated to new coordinates before appending.\n\n  let output = new PathArray();\n  if (segments[0].flat()[0] !== 'M') {\n    output = output = new PathArray('M 0 0');\n  }\n\n  segments.forEach((segment) => {\n    const flattenedOutput = output.flat();\n    let flattenedSegment = segment.flat();\n    const x = flattenedOutput[flattenedOutput.length - 2];\n    const y = flattenedOutput[flattenedOutput.length - 1];\n    let numberCounter = 0;\n\n    if (typeof x !== 'number' || typeof y !== 'number') return output;\n    for (let index = 0; index < flattenedSegment.length; index++) {\n      const element = flattenedSegment[index];\n      if (typeof element === 'number') {\n        // if element is at an even-numbered position it's an x coordidante otherwise a y coordinate\n        flattenedSegment[index] = element + (numberCounter % 2 === 0 ? x : y);\n        numberCounter += 1;\n      }\n    }\n    output = output.concat(new PathArray(flattenedSegment)) as PathArray;\n  });\n\n  return output;\n}\n","import { PathArray } from '@svgdotjs/svg.js';\nimport { pathCompose, flipY, flipX, flipXY, small } from './utils';\n\nexport type pathLibrary = { [key: string]: PathArray };\n\n////////////////////////////////////////////////////////////////////////////////////\n// basic blocks\n////////////////////////////////////////////////////////////////////////////////////\nconst loopSegment = new PathArray('C 25 50 25 100 0 100');\nconst reverseLoopSegment = new PathArray('C 25 0 25 50 0 100');\nconst curveSegment90 = new PathArray('C 50 0 100 50 100 100');\nconst reverseCurveSegment90 = new PathArray('C 0 50 50 100 100 100');\nconst curveSegment45 = new PathArray('C 50 25 75 50 100 100');\nconst reverseCurveSegment45 = new PathArray('C 25 50 50 75 100 100');\nconst connectorSegment = new PathArray('C 50 25 90 25 100 25');\nconst reverseConnectorSegment = new PathArray('C 10 0 50 0 100 25');\nconst horizontalrSegment = new PathArray('C 25 0 25 0 25 0');\n\nexport const basicBlocks: pathLibrary = {\n  loopSegment,\n  reverseLoopSegment,\n  curveSegment45,\n  reverseCurveSegment45,\n  curveSegment90,\n  reverseCurveSegment90,\n  connectorSegment,\n  reverseConnectorSegment,\n  horizontalrSegment,\n};\n\n////////////////////////////////////////////////////////////////////////////////////\n// composite shapes\n////////////////////////////////////////////////////////////////////////////////////\nexport const loop = pathCompose([\n  curveSegment45,\n  loopSegment,\n  flipXY(reverseLoopSegment),\n  flipY(reverseCurveSegment45),\n]);\nexport const crest = pathCompose([curveSegment45, flipY(reverseCurveSegment45)]);\nexport const connector = pathCompose([connectorSegment, flipY(reverseConnectorSegment)]);\nexport const twistConnector = pathCompose([connectorSegment, reverseConnectorSegment]);\nexport const drop = pathCompose([\n  curveSegment90,\n  flipX(loopSegment),\n  small(small(horizontalrSegment)),\n  flipY(reverseLoopSegment),\n  flipY(reverseCurveSegment90),\n]);\n\nexport const compositeShapes: pathLibrary = {\n  loop,\n  crest,\n  connector,\n  twistConnector,\n  drop,\n};\n\n////////////////////////////////////////////////////////////////////////////////////\n// closed shapes\n////////////////////////////////////////////////////////////////////////////////////\n\nfunction nPointRadial(radialDistances: number[]): PathArray {\n  const smoothness = 4;\n  const offset = { x: 100, y: 100 };\n  let output = new PathArray(['M', offset.x, offset.y + radialDistances[0]]);\n  const numSegments = radialDistances.length;\n\n  for (let i = 1; i < radialDistances.length + 1; i++) {\n    const d = radialDistances[i % numSegments];\n    const x = d * Math.sin((i * 2 * Math.PI) / numSegments) + offset.x;\n    const y = d * Math.cos((i * 2 * Math.PI) / numSegments) + offset.y;\n    const dX = ((-Math.cos((i * 2 * Math.PI) / numSegments) * d) / numSegments) * smoothness;\n    const dY = ((Math.sin((i * 2 * Math.PI) / numSegments) * d) / numSegments) * smoothness;\n    const controlPointX = x + dX;\n    const controlPointY = y + dY;\n\n    if (i === 1) {\n      output = output.concat([\n        'C',\n        20 + offset.x,\n        radialDistances[0] + offset.y,\n        controlPointX,\n        controlPointY,\n        x,\n        y,\n      ]) as PathArray;\n    } else {\n      output = output.concat(['S', controlPointX, controlPointY, x, y]) as PathArray;\n    }\n  }\n\n  output = output.concat(['z']) as PathArray;\n\n  return output;\n}\n\nexport const blob2 = nPointRadial([75, 75]);\nexport const blob3 = nPointRadial([75, 75, 20]);\nexport const blob4 = nPointRadial([75, 75, 20, 90]);\nexport const blob5 = nPointRadial([75, 75, 20, 100, 25]);\n\nexport const closedShapes: pathLibrary = {\n  blob2,\n  blob3,\n  blob4,\n  blob5,\n};\n","import { Svg, SVG, Path, PathArray } from '@svgdotjs/svg.js';\nimport * as library from './library';\nimport { pathCompose, toPointArray, flipY, small, big } from './utils';\n\nexport { library };\n\nfunction quickDrawPath(elementID: string, pathArray: PathArray): Path {\n  const draw: Svg = SVG().addTo(elementID).size('100%', '100%');\n  const path = draw.path(pathArray).fill('none').stroke({ color: '#000', width: 3 });\n  return path;\n}\n\nexport function drawTestCurve(elementID: string): Svg {\n  const draw: Svg = SVG().addTo(elementID).size('100%', '100%');\n  const gradient = draw.gradient('linear', function (add) {\n    add.stop(0, '#333');\n    add.stop(1, '#f03');\n  });\n  const composedPath = pathCompose([\n    small(flipY(library.crest)),\n    library.twistConnector,\n    // flipY(library.connector),\n    // library.crest,\n    small(library.loop),\n    // flipY(library.connector),\n    big(flipY(library.loop)),\n    library.connector,\n  ]);\n\n  const transformParams = {\n    rotate: 20,\n    translateX: 0,\n    translateY: 300,\n    scale: 0.5,\n    flip: 'y',\n  };\n\n  draw\n    .path(composedPath)\n    .fill('none')\n    .stroke({ color: gradient.url(), width: 3, opacity: 0.8 })\n    .transform(transformParams);\n\n  draw.polyline(toPointArray(composedPath)).fill('none').stroke({ color: '#faa', width: 0 }).transform(transformParams);\n  return draw;\n}\n\nexport function drawGallery(element: string | HTMLElement, gallery: library.pathLibrary, fill: string = 'none'): void {\n  const targetElement = element instanceof HTMLElement ? element : document.querySelector(element);\n  if (targetElement === null) return;\n  Object.keys(gallery).forEach((key) => {\n    const block = gallery[key];\n    const div = document.createElement('div');\n    div.id = key + targetElement.id;\n    div.className = 'gallery-element';\n    targetElement.appendChild(div);\n    quickDrawPath(`#${div.id}`, pathCompose([block]))\n      .transform({\n        translateX: 25,\n        translateY: 25,\n      })\n      .fill(fill);\n  });\n}\n","export function Header() {\n  return <div className=\"header\"></div>;\n}\n","export function Footer() {\n  return <div className=\"footer\"></div>;\n}\n\nexport default Footer;\n","export function Hero() {\n  return <div className=\"hero\"></div>;\n}\n","import React from 'react';\n\ntype Props = {\n  children: React.ReactNode;\n};\n\nexport function Section(props: Props) {\n  return <div className=\"section\">{props.children}</div>;\n}\n","import React, { useEffect } from 'react';\nimport './App.css';\nimport * as shapelib from '../../lib/shapelib';\nimport { Header } from '../Header';\nimport { Footer } from '../Footer';\nimport { Hero } from '../Hero';\nimport { Section } from '../Section';\n\nfunction App() {\n  useEffect(() => {\n    shapelib.drawTestCurve('#line-example');\n  });\n\n  return (\n    <div className=\"App\">\n      <Header />\n      <Section>\n        <Hero />\n      </Section>\n      <Footer />\n      {/* <div id=\"line-example\" style={{ width: '100%', height: '100%' }}></div> */}\n    </div>\n    // </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { App } from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}